#!/usr/bin/env bash

set -euo pipefail

# autoprat — batch-comment PRs with /lgtm, /approve, /ok-to-test,
# custom comments, or re-trigger commands for failed CI jobs (strips
# path prefixes for /test and /retest).

# Higher-order function for conditional actions
execute_if() {
    local condition_func="$1"
    local action_func="$2"
    shift 2
    local args=("$@")

    if "$condition_func" "${args[@]}"; then
        "$action_func" "${args[@]}"
        return 0
    fi
    return 1
}

run() {
    local cmd=("$@")
    echo "+ ${cmd[*]}"
    [[ "$dry_run" -eq 0 ]] && "${cmd[@]}"
}

get_detailed_pr_data() {
    local pr_num="$1"
    local repo_name="$2"

    local pr_view_data
    local pr_checks_data

    pr_view_data=$(gh pr view "$pr_num" --repo "$repo_name" --json number,title,author,url,createdAt,state,labels,statusCheckRollup)
    pr_checks_data=$(gh pr checks "$pr_num" --repo "$repo_name" --json name,state | jq '[.[] | {context: .name, state: (if .state == "FAILURE" or .state == "failure" or .state == "fail" then "FAILURE" else "SUCCESS" end)}]' 2>/dev/null || echo "[]")

    echo "$pr_view_data" | jq --argjson pr_checks "$pr_checks_data" '. + {extraStatusChecks: $pr_checks}'
}

declare -A comment_label_map=(
    ["/lgtm"]="lgtm"
    ["/approve"]="approved"
    ["/ok-to-test"]="ok-to-test"
)

declare -a comments=()
declare -a jobs=()
declare -A pr_titles=()
declare -A pr_authors=()

all_prs=0
dry_run=0
show_titles=0
no_pager=0           # default is to use system pager
cmd_prefix="/test"    # default CI command prefix.
repo=""
author=""
list_mode=0
needs_lgtm=0
needs_approve=0
needs_ok_to_test=0

usage() {
    cat <<EOF
Usage:
  ${0##*/} -r OWNER/REPO [OPTIONS] [PR-NUMBER]

Modes:
  List mode:   use -l/--list to view PRs without taking action
               - Use with PR-NUMBER to show details for a specific PR
               - Use without PR-NUMBER to list all PRs
  Without -a:  supply a single PR-NUMBER plus any of
               --lgtm, --approve, --ok-to-test, --comment, --job
  With -a:     omit PR-NUMBER and apply to all open PRs

Options:
  -r, --repo OWNER/REPO   GitHub repo (required)
  -l, --list              List PRs without taking action
  -a, --all               Apply to all open PRs
  --author PATTERN        Filter PRs by author (regex pattern)
  --lgtm                  Add /lgtm (if no 'lgtm' label yet)
  --approve               Add /approve (if no 'approved' label yet)
  --ok-to-test            Add /ok-to-test (if no 'ok-to-test' label yet)
  -c, --comment TEXT      Custom comment (always posted)
  -j, --job JOB-NAME      If JOB-NAME failed, post
                          "$cmd_prefix <basename-of-JOB-NAME>"
                          (repeatable)
  -x, --cmd PREFIX        Prefix for job comments (default: /test)
  -n, --dry-run           Show what would be done without posting
  -t, --show-title        Display PR titles
  --no-pager              Disable paging for command output
  --needs-lgtm            Only show PRs needing LGTM (list mode)
  --needs-approve         Only show PRs needing approval (list mode)
  --needs-ok-to-test      Only show PRs needing ok-to-test (list mode)
  -h, --help              Show this help

Examples:
  # Single PR: lgtm + approve + ok-to-test.
  ${0##*/} -r OWNER/REPO --lgtm --approve --ok-to-test 123

  # Single PR: post /retest.
  ${0##*/} -r OWNER/REPO -c /retest 123

  # All PRs: re-test a specific job.
  ${0##*/} -r OWNER/REPO -a -j ci/prow/test-fmt

  # All PRs: re-test two jobs, plus a note, dry-run.
  ${0##*/} -r OWNER/REPO -a -n \
     -j ci/prow/test-fmt \
     -j ci/prow/security \
     -x /retest \
     -c "please re-run CI"

  # Dry-run only ok-to-test on all PRs.
  ${0##*/} -r OWNER/REPO -a -n --ok-to-test

  # Dry-run only lgtm+approve on all PRs.
  ${0##*/} -r OWNER/REPO -a -n --lgtm --approve

  # Approve all PRs from a specific author.
  ${0##*/} -r OWNER/REPO -a --author "username" --approve

  # Filter PRs by author regex pattern.
  ${0##*/} -r OWNER/REPO -a --author "user.*" --lgtm

  # List all PRs in a repository.
  ${0##*/} -r OWNER/REPO --list

  # Get detailed information about a specific PR.
  ${0##*/} -r OWNER/REPO --list 488

  # List PRs from a specific author.
  ${0##*/} -r OWNER/REPO --list --author "user.*"

  # Find PRs needing approval or lgtm.
  ${0##*/} -r OWNER/REPO --list --needs-approve --needs-lgtm

EOF
    exit 1
}

pr_has_failed_job() {
    local pr="$1" job="$2"

    # Always return success (job failed) in dry-run mode for testing
    if [[ "$dry_run" -eq 1 ]]; then
        return 0
    fi

    gh pr checks "$pr" --repo "$repo" \
       --json name,state \
       --jq '.[] | select(.name == "'"$job"'" and .state == "FAILURE")' \
       >/dev/null
}

has_label() {
    local pr="$1" label="$2"

    # Always return failure (label not found) in dry-run mode for testing
    if [[ "$dry_run" -eq 1 ]]; then
        return 1
    fi

    gh pr view "$pr" --repo "$repo" \
       --json labels \
       --jq '.labels[] | select(.name == "'"$label"'")' \
       >/dev/null
}

needs_comment() {
    local pr="$1" comment="$2"
    local label="${comment_label_map[$comment]:-}"
    [[ -z "$label" ]] || ! has_label "$pr" "$label"
}

post_comment() {
    local pr="$1" comment="$2"
    local label="${comment_label_map[$comment]:-}"

    if [[ -n "$label" ]]; then
        if ! has_label "$pr" "$label"; then
            echo "    posting $comment"
            run gh pr comment "$pr" --repo "$repo" --body "$comment"
            return 0
        else
            echo "    already has '$label'; skipping $comment"
            return 1
        fi
    else
        echo "    posting $comment"
        run gh pr comment "$pr" --repo "$repo" --body "$comment"
        return 0
    fi
}

retrigger_job() {
    local pr="$1" job="$2"
    local arg

    if [[ "$cmd_prefix" == "/test" || "$cmd_prefix" == "/retest" ]]; then
        arg="${job##*/}"
    else
        arg="$job"
    fi

    echo "    retrigger: $cmd_prefix $arg"
    run gh pr comment "$pr" --repo "$repo" --body "$cmd_prefix $arg"
    return 0
}

make_pr_filter() {
    local filter_conditions=()
    [[ "$needs_lgtm" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"lgtm\"]) | not)")

    [[ "$needs_approve" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"approved\"]) | not)")

    [[ "$needs_ok_to_test" -eq 1 ]] &&
        filter_conditions+=("((.labels | map(.name) | contains([\"needs-ok-to-test\"])) or (.labels | map(.name) | contains([\"ok-to-test\"]) | not))")

    [[ -n "$author" ]] &&
        filter_conditions+=("(.author.login | test(\"$author\"))")
    local jq_filter="."
    if [[ ${#filter_conditions[@]} -gt 0 ]]; then
        local conditions
        conditions=$(printf " and %s" "${filter_conditions[@]}")
        conditions=${conditions:5}
        jq_filter="select($conditions)"
    fi

    echo "$jq_filter"
}

get_pr_data() {
    local fields="number,title,author,url,createdAt,labels,statusCheckRollup,state"
    local filter
    filter=$(make_pr_filter)

    gh pr list --repo "$repo" --state open --json "$fields" \
       --jq ".[] | $filter | \"#\\(.number) - \\(.author.login) - \\(.title)\" +
            \"\\n  State:   \\(.state) | Created: \\(.createdAt | fromdate | strftime(\"%Y-%m-%d\"))\" +
            \"\\n  URL:     \\(.url)\" +
            \"\\n  Status:\" +
            \"\\n    - Approved: \" + (if (.labels | map(.name) | contains([\"approved\"])) then \"✓\" else \"✗\" end) +
            \"\\n    - CI: \" + (if .statusCheckRollup then
                (if (.statusCheckRollup | map(select(.state == \"FAILURE\")) | length > 0)
                 then \"✗ Failing\"
                 else \"✓ Passing\"
                 end)
             else \"? Unknown\" end) +
            \"\\n    - LGTM: \" + (if (.labels | map(.name) | contains([\"lgtm\"])) then \"✓\" else \"✗\" end) +
            \"\\n    - OK-to-test: \" + (if (.labels | map(.name) | contains([\"needs-ok-to-test\"])) then \"✗\" else (if (.labels | map(.name) | contains([\"ok-to-test\"])) then \"✓\" else \"✗\" end) end) +
            \"\\n  Labels:\" +
            (if (.labels | length > 0) then
                (.labels | sort_by(.name) | map(\"\\n    - \" + .name) | join(\"\"))
             else
                \"  None\"
             end) +
            \"\\n  Checks:\" +
            (.statusCheckRollup |
                if . then
                    map(
                        select(.context != null and .context != \"\")
                    ) | sort_by(.context) | map(
                        \"\\n    - \" + .context + \": \" + .state
                    ) | join(\"\")
                else
                    \"  None\"
                end
            )"
}

post_jobs() {
    local pr="$1" did=0
    for job in "${jobs[@]}"; do
        if execute_if pr_has_failed_job retrigger_job "$pr" "$job"; then
            did=1
        else
            echo "    no failure of '$job'; skipping"
        fi
    done

    (( did > 0 ))
}

post_labels_and_comments() {
    local pr="$1" did=0
    for comment in "${comments[@]}"; do
        if execute_if "needs_comment" "post_comment" "$pr" "$comment"; then
            did=1
        fi
    done

    (( did > 0 ))
}

main() {
    local ARGS
    ARGS=$(getopt -o r:c:alnj:x:th \
                  --long repo:,comment:,all,list,author:,lgtm,approve,ok-to-test,job:,dry-run,cmd:,show-title,no-pager,needs-lgtm,needs-approve,needs-ok-to-test,help \
                  -- "$@") || usage
    eval set -- "$ARGS"

    while true; do
        case "$1" in
            -r|--repo)           repo="$2";         shift 2 ;;
            -a|--all)            all_prs=1;         shift ;;
            -l|--list)           list_mode=1;       shift ;;
            --author)            author="$2";       shift 2 ;;
            --lgtm)              comments+=("/lgtm");       shift ;;
            --approve)           comments+=("/approve");    shift ;;
            --ok-to-test)        comments+=("/ok-to-test"); shift ;;
            -c|--comment)        comments+=("$2");          shift 2 ;;
            -j|--job)            jobs+=("$2");              shift 2 ;;
            -x|--cmd)            cmd_prefix="$2";           shift 2 ;;
            -n|--dry-run)        dry_run=1;                 shift ;;
            -t|--show-title)     show_titles=1;             shift ;;
            --no-pager)          no_pager=1;                shift ;;
            --needs-lgtm)        needs_lgtm=1;              shift ;;
            --needs-approve)     needs_approve=1;           shift ;;
            --needs-ok-to-test)  needs_ok_to_test=1;        shift ;;
            -h|--help)           usage ;;
            --)                  shift; break ;;
            *)                   usage ;;
        esac
    done

    [[ -z "$repo" ]] && { echo "Error: --repo is required" >&2; exit 1; }

    if [[ "$no_pager" -eq 1 ]]; then
        export GH_PAGER=""
    fi

    if [[ "$list_mode" -eq 0 && ${#comments[@]} -eq 0 && ${#jobs[@]} -eq 0 ]]; then
        if [[ "$all_prs" -eq 1 ]]; then
            echo "Error: specify at least one of --lgtm, --approve, --ok-to-test, --comment or --job, or use --list mode" >&2
            exit 1
        elif [[ "$#" -ne 1 ]]; then
            echo "Error: specify at least one of --lgtm, --approve, --ok-to-test, --comment or --job, or use --list mode" >&2
            exit 1
        fi
    fi

    if [[ "$list_mode" -eq 1 ]]; then
        if [[ "$dry_run" -eq 1 ]]; then
            echo "List mode configuration:"
            echo "  Repository: $repo"
            echo "  Author filter: ${author:-none}"
            echo "  Needs LGTM: $needs_lgtm"
            echo "  Needs approval: $needs_approve"
            echo "  Needs ok-to-test: $needs_ok_to_test"
            echo ""
        fi

        if [[ "$all_prs" -eq 0 && $# -eq 1 ]]; then
            pr_number="$1"

            get_detailed_pr_data "$pr_number" "$repo" | \
                jq -r "
                    \"#\\(.number) - \\(.author.login) - \\(.title)\" +
                    \"\\n  State:   \\(.state) | Created: \\(.createdAt | fromdate | strftime(\"%Y-%m-%d\"))\" +
                    \"\\n  URL:     \\(.url)\" +
                    \"\\n  Status:\" +
                    \"\\n    - Approved: \" + (if (.labels | map(.name) | contains([\"approved\"])) then \"✓\" else \"✗\" end) +
                    \"\\n    - CI: \" + (
                        if (.statusCheckRollup or .extraStatusChecks) then
                            (
                                if (
                                    (.statusCheckRollup // [] | map(select(.state == \"FAILURE\")) | length > 0) or
                                    (.extraStatusChecks // [] | map(select(.state == \"FAILURE\")) | length > 0)
                                )
                                then \"✗ Failing\"
                                else \"✓ Passing\"
                                end
                            )
                        else
                            \"? Unknown\"
                        end
                    ) +
                    \"\\n    - LGTM: \" + (if (.labels | map(.name) | contains([\"lgtm\"])) then \"✓\" else \"✗\" end) +
                    \"\\n    - OK-to-test: \" + (if (.labels | map(.name) | contains([\"needs-ok-to-test\"])) then \"✗\" else (if (.labels | map(.name) | contains([\"ok-to-test\"])) then \"✓\" else \"✗\" end) end) +
                    \"\\n  Labels:\" +
                    (if (.labels | length > 0) then
                        (.labels | sort_by(.name) | map(\"\\n    - \" + .name) | join(\"\"))
                    else
                        \"  None\"
                    end) +
                    \"\\n  Checks:\" +
                    (
                        [
                            (.statusCheckRollup // [] | map({context: .context, state: .state})),
                            (.extraStatusChecks // [])
                        ] | add |
                        if length > 0 then
                            map(
                                select(.context != null and .context != \"\")
                            ) |
                            unique_by(.context) |
                            sort_by(.context) |
                            map(
                                \"\\n    - \" + .context + \": \" + .state
                            ) | join(\"\")
                        else
                            \"  None\"
                        end
                    )
                "
        else
            all_prs=1

            get_pr_data
        fi
        exit 0
    fi

    if [[ "$all_prs" -eq 1 ]]; then
        [[ $# -ne 0 ]] && usage
    else
        pr_number="$1"

        if [[ -n "$author" ]]; then
            echo "Warning: --author flag has no effect without -a flag" >&2
        fi
    fi

    if [[ "$all_prs" -eq 1 && "$show_titles" -eq 1 ]]; then
        while IFS=$'\t' read -r num title author; do
            pr_titles["$num"]="$title"
            pr_authors["$num"]="$author"
        done < <(gh pr list --repo "$repo" --state open --json number,title,author \
                    --jq '.[] | [.number, .title, .author.login] | @tsv')
    fi

    if [[ "$all_prs" -eq 1 ]]; then
        if [[ -n "$author" ]]; then
            pr_list=$(gh pr list --repo "$repo" --state open --json number,author \
                         --jq '.[] | select(.author.login | test("'"$author"'")) | .number')
        else
            pr_list=$(gh pr list --repo "$repo" --state open --json number --jq '.[].number')
        fi
    else
        pr_list="$pr_number"
    fi

    while read -r pr; do
        process_pr "$pr"
    done <<< "$pr_list"
}

process_pr() {
    local pr="$1"
    [[ -z "$pr" ]] && return

    if [[ "$show_titles" -eq 1 && -n "${pr_titles[$pr]:-}" ]]; then
        if [[ -n "${pr_authors[$pr]:-}" ]]; then
            echo "==> PR #$pr (${pr_authors[$pr]}): ${pr_titles[$pr]}"
        else
            echo "==> PR #$pr: ${pr_titles[$pr]}"
        fi
    else
        echo "==> PR #$pr"
    fi

    local did_any=0
    post_jobs "$pr"                && did_any=1
    post_labels_and_comments "$pr" && did_any=1

    [[ "$did_any" -eq 0 ]] && echo "    nothing to do"
}

main "$@"
