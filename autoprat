#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

# autoprat — batch-comment PRs with /lgtm, /approve, /ok-to-test,
# custom comments, or re-trigger commands for failed CI jobs (strips
# path prefixes for /test and /retest).

# Higher-order function for conditional actions
execute_if() {
    local condition_func="$1"
    local action_func="$2"
    shift 2
    local args=("$@")

    if "$condition_func" "${args[@]}"; then
        "$action_func" "${args[@]}"
        return 0
    fi
    return 1
}

run() {
    local cmd=("$@")
    echo "+ ${cmd[*]}"
    if [[ "$dry_run" -eq 0 ]]; then
        # Run the command and propagate errors
        "${cmd[@]}" || { echo "Error executing command" >&2; return 1; }
    fi
}

get_detailed_pr_data() {
    local pr_num="$1"
    local repo_name="$2"

    local pr_view_data
    local pr_checks_data

    pr_view_data=$(gh pr view "$pr_num" --repo "$repo_name" --json number,title,author,url,createdAt,state,labels,statusCheckRollup)
    pr_checks_data=$(gh pr checks "$pr_num" --repo "$repo_name" --json name,state | jq '[.[] | {context: .name, state: (if .state == "FAILURE" or .state == "failure" or .state == "fail" then "FAILURE" else "SUCCESS" end)}]' 2>/dev/null || echo "[]")

    echo "$pr_view_data" | jq --argjson pr_checks "$pr_checks_data" '. + {extraStatusChecks: $pr_checks}'
}

declare -A comment_label_map=(
    ["/lgtm"]="lgtm"
    ["/approve"]="approved"
    ["/ok-to-test"]="ok-to-test"
)

declare -a comments=()
declare -a jobs=()
declare -A pr_titles=()
declare -A pr_authors=()

all_prs=0
dry_run=0
show_titles=0
no_pager=0           # default is to use system pager
cmd_prefix="/test"    # default CI command prefix.
repo=""
author=""
list_mode=0
needs_lgtm=0
needs_approve=0
needs_ok_to_test=0
hold_cancel=0
verbose_status=0     # default to compact format

usage() {
    cat <<EOF
Usage:
  ${0##*/} -r OWNER/REPO [OPTIONS] [PR-NUMBER...]

Modes:
  List mode:   use -l/--list to view PRs without taking action
               - Use with PR-NUMBER to show details for a specific PR
               - Use without PR-NUMBER to list all PRs
  Without -a:  supply one or more PR-NUMBERs plus any of
               --lgtm, --approve, --ok-to-test, --comment, --job
  With -a:     omit PR-NUMBER and apply to all open PRs

Options:
  -r, --repo OWNER/REPO   GitHub repo (required)
  -l, --list              List PRs without taking action
  -a, --all               Apply to all open PRs
  --author PATTERN        Filter PRs by author (regex pattern)
  --lgtm                  Add /lgtm (if no 'lgtm' label yet)
  --approve               Add /approve (if no 'approved' label yet)
  --ok-to-test            Add /ok-to-test (only on PRs with 'needs-ok-to-test' label)
  -c, --comment TEXT      Custom comment (always posted)
  -j, --job JOB-NAME      If JOB-NAME failed, post
                          "$cmd_prefix <basename-of-JOB-NAME>"
                          (repeatable)
  -x, --cmd PREFIX        Prefix for job comments (default: /test)
  -n, --dry-run           Show what would be done without posting
  -t, --show-title        Display PR titles
  --no-pager              Disable paging for command output
  --needs-lgtm            Only show PRs needing LGTM (list mode)
  --needs-approve         Only show PRs needing approval (list mode)
  --needs-ok-to-test      Only show PRs needing ok-to-test (list mode)
  --hold-cancel           Post /hold cancel on PRs with do-not-merge/hold label
  --verbose-status        Show detailed PR status (list mode)
  -h, --help              Show this help

Examples:
  # Single PR: lgtm + approve + ok-to-test.
  ${0##*/} -r OWNER/REPO --lgtm --approve --ok-to-test 123

  # Single PR: post /retest.
  ${0##*/} -r OWNER/REPO -c /retest 123

  # Multiple PRs: post /retest.
  ${0##*/} -r OWNER/REPO -c /retest 123 456 789

  # All PRs: re-test a specific job.
  ${0##*/} -r OWNER/REPO -a -j ci/prow/test-fmt

  # All PRs: re-test two jobs, plus a note, dry-run.
  ${0##*/} -r OWNER/REPO -a -n \
     -j ci/prow/test-fmt \
     -j ci/prow/security \
     -x /retest \
     -c "please re-run CI"

  # Dry-run only ok-to-test on all PRs.
  ${0##*/} -r OWNER/REPO -a -n --ok-to-test

  # Dry-run only lgtm+approve on all PRs.
  ${0##*/} -r OWNER/REPO -a -n --lgtm --approve

  # Approve all PRs from a specific author.
  ${0##*/} -r OWNER/REPO -a --author "username" --approve

  # Filter PRs by author regex pattern.
  ${0##*/} -r OWNER/REPO -a --author "user.*" --lgtm

  # List all PRs in a repository with compact view (default).
  ${0##*/} -r OWNER/REPO --list

  # List all PRs in a repository with detailed view.
  ${0##*/} -r OWNER/REPO --list --verbose-status

  # Get detailed information about a specific PR.
  ${0##*/} -r OWNER/REPO --list 488

  # Get detailed information about multiple PRs.
  ${0##*/} -r OWNER/REPO --list 488 489 490

  # List PRs from a specific author.
  ${0##*/} -r OWNER/REPO --list --author "user.*"

  # Find PRs needing approval or lgtm.
  ${0##*/} -r OWNER/REPO --list --needs-approve --needs-lgtm

  # Remove hold on a specific PR with do-not-merge/hold label:
  ${0##*/} -r OWNER/REPO --hold-cancel 123

  # Remove hold on all PRs with do-not-merge/hold label:
  ${0##*/} -r OWNER/REPO -a --hold-cancel

  # Remove hold on PRs from a specific author:
  ${0##*/} -r OWNER/REPO -a --author "app/red-hat-konflux" --hold-cancel

EOF
    exit 1
}

pr_has_failed_job() {
    local pr="$1" job="$2"

    # Always return success (job failed) in dry-run mode for testing
    if [[ "$dry_run" -eq 1 ]]; then
        return 0
    fi

    gh pr checks "$pr" --repo "$repo" \
       --json name,state \
       --jq '.[] | select(.name == "'"$job"'" and .state == "FAILURE")' \
       >/dev/null
}

has_label() {
    local pr="$1" label="$2"

    # Check for the specific label
    local output
    output=$(gh pr view "$pr" --repo "$repo" \
       --json labels \
       --jq '.labels[] | select(.name == "'"$label"'")')

    # Return success (0) if the label was found, failure (1) otherwise
    [[ -n "$output" ]]
}

needs_comment() {
    local pr="$1" comment="$2"
    local label="${comment_label_map[$comment]:-}"

    # Return success (0) if we SHOULD post the comment
    if [[ -z "$label" ]]; then
        # No label check needed, always post
        return 0
    else
        # If has_label returns success (0), we have the label and should NOT post
        # If has_label returns failure (1), we don't have the label and should post
        if has_label "$pr" "$label"; then
            # Has the label, do NOT post
            return 1
        else
            # Doesn't have the label, DO post
            return 0
        fi
    fi
}

post_comment() {
    local pr="$1" comment="$2"
    local label="${comment_label_map[$comment]:-}"

    if [[ -n "$label" ]]; then
        if ! has_label "$pr" "$label"; then
            echo "    posting $comment"
            run gh pr comment "$pr" --repo "$repo" --body "$comment" || exit 1
            return 0
        else
            echo "    already has '$label'; skipping $comment"
            return 1
        fi
    else
        echo "    posting $comment"
        run gh pr comment "$pr" --repo "$repo" --body "$comment" || exit 1
        return 0
    fi
}

retrigger_job() {
    local pr="$1" job="$2"
    local arg

    if [[ "$cmd_prefix" == "/test" || "$cmd_prefix" == "/retest" ]]; then
        arg="${job##*/}"
    else
        arg="$job"
    fi

    echo "    retrigger: $cmd_prefix $arg"
    run gh pr comment "$pr" --repo "$repo" --body "$cmd_prefix $arg" || exit 1
    return 0
}

make_pr_filter() {
    local filter_conditions=()
    [[ "$needs_lgtm" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"lgtm\"]) | not)")

    [[ "$needs_approve" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"approved\"]) | not)")

    [[ "$needs_ok_to_test" -eq 1 ]] &&
        filter_conditions+=("((.labels | map(.name) | contains([\"needs-ok-to-test\"])) or (.labels | map(.name) | contains([\"ok-to-test\"]) | not))")

    [[ "$hold_cancel" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"do-not-merge/hold\"]))")

    [[ -n "$author" ]] &&
        filter_conditions+=("(.author.login | test(\"$author\"))")
    local jq_filter="."
    if [[ ${#filter_conditions[@]} -gt 0 ]]; then
        local conditions
        conditions=$(printf " and %s" "${filter_conditions[@]}")
        conditions=${conditions:5}
        jq_filter="select($conditions)"
    fi

    echo "$jq_filter"
}

# Function to print the compact format header
print_compact_header() {
    printf "PR | CI | APPROVED LGTM OK2TEST HOLD | AUTHOR              | TITLE\n"
    printf -- "---+----+-------------------------+--------------------+--------------------------------------\n"
}

# Function to print a PR in compact format
format_pr_compact() {
    jq -r "
    \"\\(.number)| \" +
    (if .statusCheckRollup then
        (if (.statusCheckRollup | map(select(.state == \"FAILURE\")) | length > 0)
            then \"❌\"
            else \"✅\"
        end)
    else \"❓\" end) +
    \" | \" +
    (if (.labels | map(.name) | contains([\"approved\"])) then \"✓\" else \"✗\" end) +
    \"        \" +
    (if (.labels | map(.name) | contains([\"lgtm\"])) then \"✓\" else \"✗\" end) +
    \"    \" +
    (if (.labels | map(.name) | contains([\"ok-to-test\"])) then \"✓\" else \"✗\" end) +
    \"       \" +
    (if (.labels | map(.name) | contains([\"do-not-merge/hold\"])) then \"✓\" else \"✗\" end) +
    \"  | \" +
    (.author.login | tostring | .[0:20] | if length < 20 then . + (\" \" * (20 - length)) else . end) +
    \" | \" +
    .title"
}

get_pr_data_compact() {
    local fields="number,title,author,url,createdAt,labels,statusCheckRollup,state"
    local filter
    filter=$(make_pr_filter)

    print_compact_header

    gh pr list --repo "$repo" --state open --json "$fields" \
       --jq ".[] | $filter" | format_pr_compact
}

get_pr_data_verbose() {
    local fields="number,title,author,url,createdAt,labels,statusCheckRollup,state"
    local filter
    filter=$(make_pr_filter)

    gh pr list --repo "$repo" --state open --json "$fields" \
       --jq ".[] | $filter | \"#\\(.number) - \\(.author.login) - \\(.title)\" +
            \"\\n  State:   \\(.state) | Created: \\(.createdAt | fromdate | strftime(\"%Y-%m-%d\"))\" +
            \"\\n  URL:     \\(.url)\" +
            \"\\n  Status:\" +
            \"\\n    - Approved: \" + (if (.labels | map(.name) | contains([\"approved\"])) then \"✓\" else \"✗\" end) +
            \"\\n    - CI: \" + (if .statusCheckRollup then
                (if (.statusCheckRollup | map(select(.state == \"FAILURE\")) | length > 0)
                 then \"✗ Failing\"
                 else \"✓ Passing\"
                 end)
             else \"? Unknown\" end) +
            \"\\n    - LGTM: \" + (if (.labels | map(.name) | contains([\"lgtm\"])) then \"✓\" else \"✗\" end) +
            \"\\n    - OK-to-test: \" + (if (.labels | map(.name) | contains([\"needs-ok-to-test\"])) then \"✗\" else (if (.labels | map(.name) | contains([\"ok-to-test\"])) then \"✓\" else \"✗\" end) end) +
            \"\\n  Labels:\" +
            (if (.labels | length > 0) then
                (.labels | sort_by(.name) | map(\"\\n    - \" + .name) | join(\"\"))
             else
                \"  None\"
             end) +
            \"\\n  Checks:\" +
            (.statusCheckRollup |
                if . then
                    map(
                        select(.context != null and .context != \"\")
                    ) | sort_by(.context) | map(
                        \"\\n    - \" + .context + \": \" + .state
                    ) | join(\"\")
                else
                    \"  None\"
                end
            )"
}

post_jobs() {
    local pr="$1" did=0
    for job in "${jobs[@]}"; do
        if execute_if pr_has_failed_job retrigger_job "$pr" "$job"; then
            did=1
        else
            echo "    no failure of '$job'; skipping"
        fi
    done

    (( did > 0 ))
}

pr_has_hold_label() {
    local pr="$1"

    # In dry-run mode, check but don't require the label to be present
    if [[ "$dry_run" -eq 1 ]]; then
        # Show a message if the label is missing, but still allow testing
        if ! has_label "$pr" "do-not-merge/hold"; then
            echo "    no 'do-not-merge/hold' label; would skip in non-dry-run mode"
        fi
        return 0
    fi

    # Check specifically for the do-not-merge/hold label
    has_label "$pr" "do-not-merge/hold"
}

pr_needs_ok_to_test() {
    local pr="$1"

    # In dry-run mode, check but don't require the label to be present
    if [[ "$dry_run" -eq 1 ]]; then
        # Show a message if the label is missing, but still allow testing
        if ! has_label "$pr" "needs-ok-to-test"; then
            echo "    no 'needs-ok-to-test' label; would skip in non-dry-run mode"
        fi
        return 0
    fi

    # Check specifically for the needs-ok-to-test label
    has_label "$pr" "needs-ok-to-test"
}

post_hold_cancel() {
    local pr="$1"

    echo "    posting /hold cancel to remove do-not-merge/hold label"
    run gh pr comment "$pr" --repo "$repo" --body "/hold cancel" || exit 1
    return 0
}

post_ok_to_test() {
    local pr="$1"

    echo "    posting /ok-to-test for PR with needs-ok-to-test label"
    run gh pr comment "$pr" --repo "$repo" --body "/ok-to-test" || exit 1
    return 0
}

post_labels_and_comments() {
    local pr="$1" did=0
    for comment in "${comments[@]}"; do
        if execute_if "needs_comment" "post_comment" "$pr" "$comment"; then
            did=1
        fi
    done

    (( did > 0 ))
}

main() {
    local ARGS
    ARGS=$(getopt -o r:c:alnj:x:th \
                  --long repo:,comment:,all,list,author:,lgtm,approve,ok-to-test,job:,dry-run,cmd:,show-title,no-pager,needs-lgtm,needs-approve,needs-ok-to-test,hold-cancel,verbose-status,help \
                  -- "$@") || usage
    eval set -- "$ARGS"

    while true; do
        case "$1" in
            -r|--repo)           repo="$2";         shift 2 ;;
            -a|--all)            all_prs=1;         shift ;;
            -l|--list)           list_mode=1;       shift ;;
            --author)            author="$2";       shift 2 ;;
            --lgtm)              comments+=("/lgtm");       shift ;;
            --approve)           comments+=("/approve");    shift ;;
            --ok-to-test)        comments+=("/ok-to-test"); shift ;;
            -c|--comment)        comments+=("$2");          shift 2 ;;
            -j|--job)            jobs+=("$2");              shift 2 ;;
            -x|--cmd)            cmd_prefix="$2";           shift 2 ;;
            -n|--dry-run)        dry_run=1;                 shift ;;
            -t|--show-title)     show_titles=1;             shift ;;
            --no-pager)          no_pager=1;                shift ;;
            --needs-lgtm)        needs_lgtm=1;              shift ;;
            --needs-approve)     needs_approve=1;           shift ;;
            --needs-ok-to-test)  needs_ok_to_test=1;        shift ;;
            --hold-cancel)       hold_cancel=1;             shift ;;
            --verbose-status)    verbose_status=1;          shift ;;
            -h|--help)           usage ;;
            --)                  shift; break ;;
            *)                   usage ;;
        esac
    done

    [[ -z "$repo" ]] && { echo "Error: --repo is required" >&2; exit 1; }

    if [[ "$no_pager" -eq 1 ]]; then
        export GH_PAGER=""
    fi

    if [[ "$list_mode" -eq 0 && ${#comments[@]} -eq 0 && ${#jobs[@]} -eq 0 && "$hold_cancel" -eq 0 ]]; then
        if [[ "$all_prs" -eq 1 ]]; then
            echo "Error: specify at least one of --lgtm, --approve, --ok-to-test, --comment, --job, or --hold-cancel, or use --list mode" >&2
            exit 1
        elif [[ "$#" -lt 1 ]]; then
            echo "Error: specify at least one of --lgtm, --approve, --ok-to-test, --comment, --job, or --hold-cancel, or use --list mode" >&2
            exit 1
        fi
    fi


    if [[ "$list_mode" -eq 1 ]]; then
        if [[ "$dry_run" -eq 1 ]]; then
            echo "List mode configuration:"
            echo "  Repository: $repo"
            echo "  Author filter: ${author:-none}"
            echo "  Needs LGTM: $needs_lgtm"
            echo "  Needs approval: $needs_approve"
            echo "  Needs ok-to-test: $needs_ok_to_test"
            echo "  Output format: $([ "$verbose_status" -eq 1 ] && echo "verbose" || echo "compact")"
            echo ""
        fi

        if [[ "$all_prs" -eq 0 && $# -gt 0 ]]; then
            # Force verbose mode for individual PRs
            verbose_status=1

            # Handle multiple PR numbers in list mode
            for pr_number in "$@"; do
                get_detailed_pr_data "$pr_number" "$repo" | \
                    jq -r "
                        \"#\\(.number) - \\(.author.login) - \\(.title)\" +
                        \"\\n  State:   \\(.state) | Created: \\(.createdAt | fromdate | strftime(\"%Y-%m-%d\"))\" +
                        \"\\n  URL:     \\(.url)\" +
                        \"\\n  Status:\" +
                        \"\\n    - Approved: \" + (if (.labels | map(.name) | contains([\"approved\"])) then \"✓\" else \"✗\" end) +
                        \"\\n    - CI: \" + (
                            if (.statusCheckRollup or .extraStatusChecks) then
                                (
                                    if (
                                        (.statusCheckRollup // [] | map(select(.state == \"FAILURE\")) | length > 0) or
                                        (.extraStatusChecks // [] | map(select(.state == \"FAILURE\")) | length > 0)
                                    )
                                    then \"✗ Failing\"
                                    else \"✓ Passing\"
                                    end
                                )
                            else
                                \"? Unknown\"
                            end
                        ) +
                        \"\\n    - LGTM: \" + (if (.labels | map(.name) | contains([\"lgtm\"])) then \"✓\" else \"✗\" end) +
                        \"\\n    - OK-to-test: \" + (if (.labels | map(.name) | contains([\"needs-ok-to-test\"])) then \"✗\" else (if (.labels | map(.name) | contains([\"ok-to-test\"])) then \"✓\" else \"✗\" end) end) +
                        \"\\n  Labels:\" +
                        (if (.labels | length > 0) then
                            (.labels | sort_by(.name) | map(\"\\n    - \" + .name) | join(\"\"))
                        else
                            \"  None\"
                        end) +
                        \"\\n  Checks:\" +
                        (
                            [
                                (.statusCheckRollup // [] | map({context: .context, state: .state})),
                                (.extraStatusChecks // [])
                            ] | add |
                            if length > 0 then
                                map(
                                    select(.context != null and .context != \"\")
                                ) |
                                unique_by(.context) |
                                sort_by(.context) |
                                map(
                                    \"\\n    - \" + .context + \": \" + .state
                                ) | join(\"\")
                            else
                                \"  None\"
                            end
                        )
                    "
                echo ""
            done
        else
            all_prs=1

            if [[ "$verbose_status" -eq 1 ]]; then
                get_pr_data_verbose
            else
                get_pr_data_compact
            fi
        fi
        exit 0
    fi

    if [[ "$all_prs" -eq 1 ]]; then
        [[ $# -ne 0 ]] && usage
    else
        # When not using -a/--all, require at least one PR number
        [[ $# -lt 1 ]] && usage

        if [[ -n "$author" ]]; then
            echo "Warning: --author flag has no effect without -a flag" >&2
        fi
    fi

    if [[ "$all_prs" -eq 1 && "$show_titles" -eq 1 ]]; then
        while IFS=$'\t' read -r num title author; do
            pr_titles["$num"]="$title"
            pr_authors["$num"]="$author"
        done < <(gh pr list --repo "$repo" --state open --json number,title,author \
                    --jq '.[] | [.number, .title, .author.login] | @tsv')
    fi

    # Get list of PRs to process
    declare -a pr_list=()

    if [[ "$all_prs" -eq 1 ]]; then
        # Get all open PRs
        if [[ -n "$author" ]]; then
            # With author filter
            mapfile -t pr_list < <(gh pr list --repo "$repo" --state open --json number,author \
                        --jq '.[] | select(.author.login | test("'"$author"'")) | .number')
        else
            # All PRs
            mapfile -t pr_list < <(gh pr list --repo "$repo" --state open --json number --jq '.[].number')
        fi
    else
        # Store PR numbers from arguments
        for arg in "$@"; do
            pr_list+=("$arg")
        done
    fi

    # Process each PR
    for pr in "${pr_list[@]}"; do
        process_pr "$pr"  # Fail fast if there's an error
    done
}

process_pr() {
    local pr="$1"

    # Skip empty PR numbers
    [[ -z "$pr" ]] && return

    if [[ "$show_titles" -eq 1 && -n "${pr_titles[$pr]:-}" ]]; then
        if [[ -n "${pr_authors[$pr]:-}" ]]; then
            echo "==> PR #$pr (${pr_authors[$pr]}): ${pr_titles[$pr]}"
        else
            echo "==> PR #$pr: ${pr_titles[$pr]}"
        fi
    else
        echo "==> PR #$pr"
    fi

    local did_any=0
    set +e  # Disable exit on error for these function calls

    # Check for ok-to-test in comments and handle separately
    local has_ok_to_test=0
    for comment in "${comments[@]}"; do
        if [[ "$comment" == "/ok-to-test" ]]; then
            has_ok_to_test=1
            break
        fi
    done

    if [[ "$has_ok_to_test" -eq 1 ]]; then
        # Remove /ok-to-test from comments array to prevent default handling
        local filtered_comments=()
        for comment in "${comments[@]}"; do
            if [[ "$comment" != "/ok-to-test" ]]; then
                filtered_comments+=("$comment")
            fi
        done
        comments=("${filtered_comments[@]}")

        # Only post /ok-to-test if PR has needs-ok-to-test label
        execute_if pr_needs_ok_to_test post_ok_to_test "$pr" && did_any=1
    fi

    post_jobs "$pr" && did_any=1
    post_labels_and_comments "$pr" && did_any=1

    # Handle hold cancel if flag is set
    if [[ "$hold_cancel" -eq 1 ]]; then
        execute_if pr_has_hold_label post_hold_cancel "$pr" && did_any=1
    fi

    set -e  # Re-enable exit on error

    [[ "$did_any" -eq 0 ]] && echo "    nothing to do"

    # Always return success from process_pr
    return 0
}

main "$@"
