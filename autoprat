#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

# autoprat â€” batch-comment PRs with /lgtm, /approve, /ok-to-test,
# custom comments, or re-trigger commands for failed CI jobs (strips
# path prefixes for /test and /retest).

# Higher-order function for conditional actions
execute_if() {
    local condition_func="$1"
    local action_func="$2"
    shift 2
    local args=("$@")

    if "$condition_func" "${args[@]}"; then
        "$action_func" "${args[@]}"
        return 0
    fi
    return 1
}

run() {
    local cmd=("$@")
    echo "+ ${cmd[*]}"
    if [[ "$dry_run" -eq 0 ]]; then
        # Run the command and propagate errors
        "${cmd[@]}" || { echo "Error executing command" >&2; return 1; }
    fi
}

get_detailed_pr_data() {
    local pr_num="$1"
    local repo_name="$2"

    local pr_view_data
    local pr_checks_data

    pr_view_data=$(gh pr view "$pr_num" --repo "$repo_name" --json number,title,author,url,createdAt,state,labels,statusCheckRollup)
    pr_checks_data=$(gh pr checks "$pr_num" --repo "$repo_name" --json name,state | jq '[.[] | {context: .name, state: (if .state == "FAILURE" or .state == "failure" or .state == "fail" then "FAILURE" else "SUCCESS" end)}]' 2>/dev/null || echo "[]")

    echo "$pr_view_data" | jq --argjson pr_checks "$pr_checks_data" '. + {extraStatusChecks: $pr_checks}'
}

declare -A comment_label_map=(
    ["/lgtm"]="lgtm"
    ["/approve"]="approved"
    ["/ok-to-test"]="ok-to-test"
)

declare -a comments=()
declare -a jobs=()
declare -A pr_titles=()
declare -A pr_authors=()

all_prs=0
dry_run=0
show_titles=0
no_pager=0           # default is to use system pager
cmd_prefix="/test"    # default CI command prefix.
repo=""
author=""
list_mode=0
needs_lgtm=0
needs_approve=0
needs_ok_to_test=0
hold_cancel=0
verbose_status=0     # default to compact format
failing_ci=0         # option to list only failing CI PRs
# Always show clickable URLs in the compact format

usage() {
    cat <<EOF
Usage:
  ${0##*/} -r OWNER/REPO [OPTIONS] [PR-NUMBER...]

Modes:
  List mode:   use -l/--list to view PRs without taking action
               - Use with PR-NUMBER to show details for a specific PR
               - Use without PR-NUMBER to list all PRs
  Without -A:  supply one or more PR-NUMBERs plus any of
               --lgtm, --approve, --ok-to-test, --comment, --job
  With -A:     omit PR-NUMBER and apply to all open PRs

Options:
  -r, --repo OWNER/REPO   GitHub repo (required)
  -l, --list              List PRs without taking action
  -A, --all               Apply to all open PRs
  -a, --author PATTERN    Filter PRs by author (regex pattern)
  --lgtm                  Add /lgtm (if no 'lgtm' label yet)
  --approve               Add /approve (if no 'approved' label yet)
  --ok-to-test            Add /ok-to-test (only on PRs with 'needs-ok-to-test' label)
  -c, --comment TEXT      Custom comment (always posted)
  -j, --job JOB-NAME      If JOB-NAME failed, post
                          "$cmd_prefix <basename-of-JOB-NAME>"
                          (repeatable)
  -x, --cmd PREFIX        Prefix for job comments (default: /test)
  -n, --dry-run           Show what would be done without posting
  -t, --show-title        Display PR titles
  --no-pager              Disable paging for command output
  --needs-lgtm            Only show PRs needing LGTM (list mode)
  --needs-approve         Only show PRs needing approval (list mode)
  --needs-ok-to-test      Only show PRs needing ok-to-test (list mode)
  --hold-cancel           Post /hold cancel on PRs with do-not-merge/hold label
  -v, --verbose-status    Show detailed PR status (list mode)
  -f, --failing-ci        Only show PR numbers with failing CI (useful for piping)
  -h, --help              Show this help

Examples:
  # Single PR: lgtm + approve + ok-to-test.
  ${0##*/} -r OWNER/REPO --lgtm --approve --ok-to-test 123

  # Single PR: post /retest.
  ${0##*/} -r OWNER/REPO -c /retest 123

  # Multiple PRs: post /retest.
  ${0##*/} -r OWNER/REPO -c /retest 123 456 789

  # All PRs: re-test a specific job.
  ${0##*/} -r OWNER/REPO -A -j ci/prow/test-fmt

  # All PRs: re-test two jobs, plus a note, dry-run.
  ${0##*/} -r OWNER/REPO -A -n \
     -j ci/prow/test-fmt \
     -j ci/prow/security \
     -x /retest \
     -c "please re-run CI"

  # Dry-run only ok-to-test on all PRs.
  ${0##*/} -r OWNER/REPO -A -n --ok-to-test

  # Dry-run only lgtm+approve on all PRs.
  ${0##*/} -r OWNER/REPO -A -n --lgtm --approve

  # Approve all PRs from a specific author.
  ${0##*/} -r OWNER/REPO -A --author "username" --approve

  # Filter PRs by author regex pattern.
  ${0##*/} -r OWNER/REPO -A --author "user.*" --lgtm

  # List all PRs in a repository with compact view (default).
  ${0##*/} -r OWNER/REPO --list

  # List all PRs in a repository with detailed view.
  ${0##*/} -r OWNER/REPO --list --verbose-status

  # Get detailed information about a specific PR.
  ${0##*/} -r OWNER/REPO --list 488

  # Get detailed information about multiple PRs.
  ${0##*/} -r OWNER/REPO --list 488 489 490

  # List PRs from a specific author.
  ${0##*/} -r OWNER/REPO --list --author "user.*"

  # Find PRs needing approval or lgtm.
  ${0##*/} -r OWNER/REPO --list --needs-approve --needs-lgtm

  # Remove hold on a specific PR with do-not-merge/hold label:
  ${0##*/} -r OWNER/REPO --hold-cancel 123

  # Remove hold on all PRs with do-not-merge/hold label:
  ${0##*/} -r OWNER/REPO -A --hold-cancel

  # Remove hold on PRs from a specific author:
  ${0##*/} -r OWNER/REPO -A --author "app/red-hat-konflux" --hold-cancel

EOF
    exit 1
}

pr_has_failed_job() {
    local pr="$1" job="$2"

    # Always return success (job failed) in dry-run mode for testing
    if [[ "$dry_run" -eq 1 ]]; then
        return 0
    fi

    gh pr checks "$pr" --repo "$repo" \
       --json name,state \
       --jq '.[] | select(.name == "'"$job"'" and .state == "FAILURE")' \
       >/dev/null
}

has_label() {
    local pr="$1" label="$2"

    # Check for the specific label
    local output
    output=$(gh pr view "$pr" --repo "$repo" \
       --json labels \
       --jq '.labels[] | select(.name == "'"$label"'")')

    # Return success (0) if the label was found, failure (1) otherwise
    [[ -n "$output" ]]
}

needs_comment() {
    local pr="$1" comment="$2"
    local label="${comment_label_map[$comment]:-}"

    # Return success (0) if we SHOULD post the comment
    if [[ -z "$label" ]]; then
        # No label check needed, always post
        return 0
    else
        # If has_label returns success (0), we have the label and should NOT post
        # If has_label returns failure (1), we don't have the label and should post
        if has_label "$pr" "$label"; then
            # Has the label, do NOT post
            return 1
        else
            # Doesn't have the label, DO post
            return 0
        fi
    fi
}

post_comment() {
    local pr="$1" comment="$2"
    local label="${comment_label_map[$comment]:-}"

    if [[ -n "$label" ]]; then
        if ! has_label "$pr" "$label"; then
            echo "    posting $comment"
            run gh pr comment "$pr" --repo "$repo" --body "$comment" || exit 1
            return 0
        else
            echo "    already has '$label'; skipping $comment"
            return 1
        fi
    else
        echo "    posting $comment"
        run gh pr comment "$pr" --repo "$repo" --body "$comment" || exit 1
        return 0
    fi
}

retrigger_job() {
    local pr="$1" job="$2"
    local arg

    if [[ "$cmd_prefix" == "/test" || "$cmd_prefix" == "/retest" ]]; then
        arg="${job##*/}"
    else
        arg="$job"
    fi

    echo "    retrigger: $cmd_prefix $arg"
    run gh pr comment "$pr" --repo "$repo" --body "$cmd_prefix $arg" || exit 1
    return 0
}

make_pr_filter() {
    local filter_conditions=()
    [[ "$needs_lgtm" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"lgtm\"]) | not)")

    [[ "$needs_approve" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"approved\"]) | not)")

    [[ "$needs_ok_to_test" -eq 1 ]] &&
        filter_conditions+=("((.labels | map(.name) | contains([\"needs-ok-to-test\"])) or (.labels | map(.name) | contains([\"ok-to-test\"]) | not))")

    [[ "$hold_cancel" -eq 1 ]] &&
        filter_conditions+=("(.labels | map(.name) | contains([\"do-not-merge/hold\"]))")

    [[ "$failing_ci" -eq 1 ]] &&
        filter_conditions+=("(.statusCheckRollup | map(select(.state == \"FAILURE\")) | length > 0)")

    [[ -n "$author" ]] &&
        filter_conditions+=("(.author.login | test(\"$author\"))")
    local jq_filter="."
    if [[ ${#filter_conditions[@]} -gt 0 ]]; then
        local conditions
        conditions=$(printf " and %s" "${filter_conditions[@]}")
        conditions=${conditions:5}
        jq_filter="select($conditions)"
    fi

    echo "$jq_filter"
}

# Function to print the compact format header
print_compact_header() {
    echo "PR URL|CI|APPROVED|LGTM|OK2TEST|HOLD|AUTHOR|TITLE"
}

# Function to format PR data as tree format
format_pr_tree_data() {
    jq -r "
    \"1|0|\\(.url)\\n\" +
    \"2|1|Title: \\(.title) (\\(.author.login))\\n\" +
    \"3|1|PR #\\(.number)\\n\" +
    \"4|1|State: \\(.state)\\n\" +
    \"5|1|Created: \\(.createdAt | fromdate | strftime(\"%Y-%m-%d %H:%M:%S\"))\\n\" +
    \"6|1|Status\\n\" +
    \"7|6|Approved: \" + (if (.labels | map(.name) | contains([\"approved\"])) then \"Yes\" else \"No\" end) + \"\\n\" +
    \"8|6|CI: \" + (
        if (.statusCheckRollup or .extraStatusChecks) then
            (
                if (
                    (.statusCheckRollup // [] | map(select(.state == \"FAILURE\")) | length > 0) or
                    (.extraStatusChecks // [] | map(select(.state == \"FAILURE\")) | length > 0)
                )
                then \"Failing\"
                else
                    (if (
                        (.statusCheckRollup // [] | map(select(.state == \"PENDING\")) | length > 0) or
                        (.extraStatusChecks // [] | map(select(.state == \"PENDING\")) | length > 0)
                    )
                    then \"Pending\"
                    else \"Passing\"
                    end)
                end
            )
        else
            \"Unknown\"
        end
    ) + \"\\n\" +
    \"9|6|LGTM: \" + (if (.labels | map(.name) | contains([\"lgtm\"])) then \"Yes\" else \"No\" end) + \"\\n\" +
    \"10|6|OK-to-test: \" + (if (.labels | map(.name) | contains([\"needs-ok-to-test\"])) then \"No\" else (if (.labels | map(.name) | contains([\"ok-to-test\"])) then \"Yes\" else \"No\" end) end) + \"\\n\" +
    \"20|1|Labels\" +
    (if (.labels | length > 0) then
        (.labels | sort_by(.name) | to_entries | map(\"\\n\" + (21 + .key | tostring) + \"|20|\" + .value.name) | join(\"\"))
    else
        \"\\n21|20|None\"
    end) + \"\\n\" +
    \"100|1|Checks\" +
    (
        [
            (.statusCheckRollup // [] | map({context: .context, state: .state})),
            (.extraStatusChecks // [])
        ] | add |
        if length > 0 then
            map(
                select(.context != null and .context != \"\")
            ) |
            unique_by(.context) |
            sort_by(.context) |
            to_entries |
            map(\"\\n\" + (101 + .key | tostring) + \"|100|\" + .value.context + \": \" + .value.state) |
            join(\"\")
        else
            \"\\n101|100|None\"
        end
    )"
}

# Function to print a PR in compact format
format_pr_compact() {
    jq -r "
    \"\\(.url)|\" +
    (if .statusCheckRollup then
        (if (.statusCheckRollup | map(select(.state == \"FAILURE\")) | length > 0)
            then \"FAIL\"
            else
                (if (.statusCheckRollup | map(select(.state == \"PENDING\")) | length > 0)
                    then \"PENDING\"
                    else \"PASS\"
                end)
        end)
    else \"?\" end) +
    \"|\" +
    (if (.labels | map(.name) | contains([\"approved\"])) then \"Y\" else \"N\" end) +
    \"|\" +
    (if (.labels | map(.name) | contains([\"lgtm\"])) then \"Y\" else \"N\" end) +
    \"|\" +
    (if (.labels | map(.name) | contains([\"ok-to-test\"])) then \"Y\" else \"N\" end) +
    \"|\" +
    (if (.labels | map(.name) | contains([\"do-not-merge/hold\"])) then \"Y\" else \"N\" end) +
    \"|\" +
    .author.login +
    \"|\" +
    .title"
}

get_pr_data_compact() {
    local fields="number,title,author,url,createdAt,labels,statusCheckRollup,state"
    local filter
    filter=$(make_pr_filter)

    # Create a temporary file to store the data
    local tempfile
    tempfile=$(mktemp)

    # Write the header and data to the temp file
    print_compact_header > "$tempfile"
    gh pr list --repo "$repo" --state open --json "$fields" \
       --jq ".[] | $filter" | format_pr_compact >> "$tempfile"

    # Format the output using column
    column -t -s'|' "$tempfile"

    # Remove the temporary file
    rm -f "$tempfile"
}

get_pr_data_verbose() {
    local fields="number,title,author,url,createdAt,labels,statusCheckRollup,state"
    local filter
    filter=$(make_pr_filter)

    # Get all matching PR numbers first
    local pr_numbers_file
    pr_numbers_file=$(mktemp)
    gh pr list --repo "$repo" --state open --json "$fields" \
       --jq ".[] | $filter | .number" > "$pr_numbers_file" 2>/dev/null || true

    # If we're in dry run mode and there are no PRs matching the filter, provide an example
    if [[ "$dry_run" -eq 1 ]] && [[ ! -s "$pr_numbers_file" ]]; then
        echo "Note: No PRs match your filter criteria in dry-run mode. Using example PR format:"
        echo ""
        echo "PR #123: Example PR Title (example-user)"
        echo "â”œâ”€State: OPEN | Created: 2025-01-01"
        echo "â”œâ”€URL: https://github.com/example/repo/pull/123"
        echo "â”œâ”€Status"
        echo "â”‚ â”œâ”€Approved: No"
        echo "â”‚ â”œâ”€CI: Pending"
        echo "â”‚ â”œâ”€LGTM: No"
        echo "â”‚ â””â”€OK-to-test: Yes"
        echo "â”œâ”€Labels"
        echo "â”‚ â”œâ”€needs-ok-to-test"
        echo "â”‚ â””â”€size/S"
        echo "â””â”€Checks"
        echo "  â”œâ”€ci/prow/verify: PENDING"
        echo "  â””â”€tide: PENDING"
        echo ""
        rm -f "$pr_numbers_file"
        return
    fi

    # Process each PR separately to handle extraStatusChecks properly
    while read -r pr_number; do
        # Skip empty lines
        [[ -z "$pr_number" ]] && continue

        # Process each PR like we do in individual PR mode
        local tempfile
        tempfile=$(mktemp)

        get_detailed_pr_data "$pr_number" "$repo" | \
            format_pr_tree_data > "$tempfile"

        # Use column to format the output as a tree, hiding the ID columns
        column --separator "|" --tree-id 1 --tree-parent 2 --tree 3 --output-width $(tput cols) --table-hide 1,2 "$tempfile"

        # Remove the temporary file
        rm -f "$tempfile"

        echo ""
    done < "$pr_numbers_file"

    # Clean up
    rm -f "$pr_numbers_file"
}

post_jobs() {
    local pr="$1" did=0
    for job in "${jobs[@]}"; do
        if execute_if pr_has_failed_job retrigger_job "$pr" "$job"; then
            did=1
        else
            echo "    no failure of '$job'; skipping"
        fi
    done

    (( did > 0 ))
}

pr_has_hold_label() {
    local pr="$1"

    # In dry-run mode, check but don't require the label to be present
    if [[ "$dry_run" -eq 1 ]]; then
        # Show a message if the label is missing, but still allow testing
        if ! has_label "$pr" "do-not-merge/hold"; then
            echo "    no 'do-not-merge/hold' label; would skip in non-dry-run mode"
        fi
        return 0
    fi

    # Check specifically for the do-not-merge/hold label
    has_label "$pr" "do-not-merge/hold"
}

pr_needs_ok_to_test() {
    local pr="$1"

    # In dry-run mode, check but don't require the label to be present
    if [[ "$dry_run" -eq 1 ]]; then
        # Show a message if the label is missing, but still allow testing
        if ! has_label "$pr" "needs-ok-to-test"; then
            echo "    no 'needs-ok-to-test' label; would skip in non-dry-run mode"
        fi
        return 0
    fi

    # Check specifically for the needs-ok-to-test label
    has_label "$pr" "needs-ok-to-test"
}

post_hold_cancel() {
    local pr="$1"

    echo "    posting /hold cancel to remove do-not-merge/hold label"
    run gh pr comment "$pr" --repo "$repo" --body "/hold cancel" || exit 1
    return 0
}

post_ok_to_test() {
    local pr="$1"

    echo "    posting /ok-to-test for PR with needs-ok-to-test label"
    run gh pr comment "$pr" --repo "$repo" --body "/ok-to-test" || exit 1
    return 0
}

post_labels_and_comments() {
    local pr="$1" did=0
    for comment in "${comments[@]}"; do
        if execute_if "needs_comment" "post_comment" "$pr" "$comment"; then
            did=1
        fi
    done

    (( did > 0 ))
}

main() {
    local ARGS
    ARGS=$(getopt -o r:c:Alna:j:x:thvf \
                  --long repo:,comment:,all,list,author:,lgtm,approve,ok-to-test,job:,dry-run,cmd:,show-title,no-pager,needs-lgtm,needs-approve,needs-ok-to-test,hold-cancel,verbose-status,failing-ci,help \
                  -- "$@") || usage
    eval set -- "$ARGS"

    while true; do
        case "$1" in
            -r|--repo)           repo="$2";         shift 2 ;;
            -A|--all)            all_prs=1;         shift ;;
            -l|--list)           list_mode=1;       shift ;;
            -a|--author)         author="$2";       shift 2 ;;
            --lgtm)              comments+=("/lgtm");       shift ;;
            --approve)           comments+=("/approve");    shift ;;
            --ok-to-test)        comments+=("/ok-to-test"); shift ;;
            -c|--comment)        comments+=("$2");          shift 2 ;;
            -j|--job)            jobs+=("$2");              shift 2 ;;
            -x|--cmd)            cmd_prefix="$2";           shift 2 ;;
            -n|--dry-run)        dry_run=1;                 shift ;;
            -t|--show-title)     show_titles=1;             shift ;;
            --no-pager)          no_pager=1;                shift ;;
            --needs-lgtm)        needs_lgtm=1;              shift ;;
            --needs-approve)     needs_approve=1;           shift ;;
            --needs-ok-to-test)  needs_ok_to_test=1;        shift ;;
            --hold-cancel)       hold_cancel=1;             shift ;;
            -v|--verbose-status) verbose_status=1;          shift ;;
            -f|--failing-ci) failing_ci=1;           shift ;;
            -h|--help)           usage ;;
            --)                  shift; break ;;
            *)                   usage ;;
        esac
    done

    [[ -z "$repo" ]] && { echo "Error: --repo is required" >&2; exit 1; }

    if [[ "$no_pager" -eq 1 ]]; then
        export GH_PAGER=""
    fi

    if [[ "$list_mode" -eq 0 && ${#comments[@]} -eq 0 && ${#jobs[@]} -eq 0 && "$hold_cancel" -eq 0 ]]; then
        if [[ "$all_prs" -eq 1 ]]; then
            echo "Error: specify at least one of --lgtm, --approve, --ok-to-test, --comment, --job, or --hold-cancel, or use --list mode" >&2
            exit 1
        elif [[ "$#" -lt 1 ]]; then
            echo "Error: specify at least one of --lgtm, --approve, --ok-to-test, --comment, --job, or --hold-cancel, or use --list mode" >&2
            exit 1
        fi
    fi


    if [[ "$list_mode" -eq 1 ]]; then
        # Handle failing CI option specially - only output PR numbers
        if [[ "$failing_ci" -eq 1 ]]; then
            # Get PR numbers with failing CI for use in piping
            local fields="number,statusCheckRollup"
            local filter
            filter=$(make_pr_filter)
            gh pr list --repo "$repo" --state open --json "$fields" \
               --jq ".[] | $filter | .number"
            exit 0
        fi

        # Only show configuration in list mode when in dry-run mode
        if [[ "$dry_run" -eq 1 ]]; then
            echo "List mode configuration (dry-run):"
            echo "  Repository: $repo"
            echo "  Author filter: ${author:-none}"
            echo "  Needs LGTM: $needs_lgtm"
            echo "  Needs approval: $needs_approve"
            echo "  Needs ok-to-test: $needs_ok_to_test"
            echo "  Output format: $([ "$verbose_status" -eq 1 ] && echo "verbose" || echo "compact")"
            echo ""
        fi

        if [[ "$all_prs" -eq 0 && $# -gt 0 ]]; then
            # Force verbose mode for individual PRs
            verbose_status=1

            # Handle multiple PR numbers in list mode
            for pr_number in "$@"; do
                # Create a temporary file for the tree data
                local tempfile
                tempfile=$(mktemp)

                get_detailed_pr_data "$pr_number" "$repo" | \
                    format_pr_tree_data > "$tempfile"

                # Use column to format the output as a tree, hiding the ID columns
                column --separator "|" --tree-id 1 --tree-parent 2 --tree 3 --output-width $(tput cols) --table-hide 1,2 "$tempfile"

                # Remove the temporary file
                rm -f "$tempfile"

                echo ""
            done
        else
            all_prs=1

            if [[ "$verbose_status" -eq 1 ]]; then
                get_pr_data_verbose
            else
                get_pr_data_compact
            fi
        fi
        exit 0
    fi

    if [[ "$all_prs" -eq 1 ]]; then
        [[ $# -ne 0 ]] && usage
    else
        # When not using -A/--all, require at least one PR number
        [[ $# -lt 1 ]] && usage

        if [[ -n "$author" ]]; then
            echo "Warning: -a/--author flag has no effect without -A flag" >&2
        fi
    fi

    if [[ "$all_prs" -eq 1 && "$show_titles" -eq 1 ]]; then
        while IFS=$'\t' read -r num title author; do
            pr_titles["$num"]="$title"
            pr_authors["$num"]="$author"
        done < <(gh pr list --repo "$repo" --state open --json number,title,author \
                    --jq '.[] | [.number, .title, .author.login] | @tsv')
    fi

    # Get list of PRs to process
    declare -a pr_list=()

    if [[ "$all_prs" -eq 1 ]]; then
        # Get all open PRs
        if [[ -n "$author" ]]; then
            # With author filter
            mapfile -t pr_list < <(gh pr list --repo "$repo" --state open --json number,author \
                        --jq '.[] | select(.author.login | test("'"$author"'")) | .number')
        else
            # All PRs
            mapfile -t pr_list < <(gh pr list --repo "$repo" --state open --json number --jq '.[].number')
        fi
    else
        # Store PR numbers from arguments
        for arg in "$@"; do
            pr_list+=("$arg")
        done
    fi

    # Process each PR
    for pr in "${pr_list[@]}"; do
        process_pr "$pr"  # Fail fast if there's an error
    done
}

process_pr() {
    local pr="$1"

    # Skip empty PR numbers
    [[ -z "$pr" ]] && return

    if [[ "$show_titles" -eq 1 && -n "${pr_titles[$pr]:-}" ]]; then
        if [[ -n "${pr_authors[$pr]:-}" ]]; then
            echo "==> PR #$pr (${pr_authors[$pr]}): ${pr_titles[$pr]}"
        else
            echo "==> PR #$pr: ${pr_titles[$pr]}"
        fi
    else
        echo "==> PR #$pr"
    fi

    local did_any=0
    set +e  # Disable exit on error for these function calls

    # Check for ok-to-test in comments and handle separately
    local has_ok_to_test=0
    for comment in "${comments[@]}"; do
        if [[ "$comment" == "/ok-to-test" ]]; then
            has_ok_to_test=1
            break
        fi
    done

    if [[ "$has_ok_to_test" -eq 1 ]]; then
        # Remove /ok-to-test from comments array to prevent default handling
        local filtered_comments=()
        for comment in "${comments[@]}"; do
            if [[ "$comment" != "/ok-to-test" ]]; then
                filtered_comments+=("$comment")
            fi
        done
        comments=("${filtered_comments[@]}")

        # Only post /ok-to-test if PR has needs-ok-to-test label
        execute_if pr_needs_ok_to_test post_ok_to_test "$pr" && did_any=1
    fi

    post_jobs "$pr" && did_any=1
    post_labels_and_comments "$pr" && did_any=1

    # Handle hold cancel if flag is set
    if [[ "$hold_cancel" -eq 1 ]]; then
        execute_if pr_has_hold_label post_hold_cancel "$pr" && did_any=1
    fi

    set -e  # Re-enable exit on error

    [[ "$did_any" -eq 0 ]] && echo "    nothing to do"

    # Always return success from process_pr
    return 0
}

main "$@"
